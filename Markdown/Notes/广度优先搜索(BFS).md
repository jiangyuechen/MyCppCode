## 广 度 优 先 搜 索 ( B F S )

##### 0.前言

~~三天的精力之屑作~~

我尽量将我的课讲得生动活泼一些，我的课件重在让大家理解算法的实质，并且图会比较多。

我知道你们很想看代码怎么写，然而代码在我的课件里占比并不大。别着急，慢慢来。

##### 1.问题的出现和引入

看下面这张图：

![捕获](E:\课件\捕获.PNG)

假设有一个“马”从S处放入，像中国象棋一样，要你通过”马走日“的方式走到F格，并要求走过的步数最小，求出这个最小值。

这道题可以用DFS搜索，并且很快就能找到一个解：$A1\to C2\to D4$，只有两步。但是DFS怎么知道这就是最短的路径呢？虽然我们一眼就知道这条路的步数最小，可是计算机又不是人类。所以它要尝试其它的道路，把整张图可能的路径都搜索一遍，如果一次搜索中的步数比之前的最小值还小，那么就要更新这个最小值。你会发现，无论怎么更新，最小值都是$2$，所以说其它的尝试都是徒劳的。也就是说，DFS的时间复杂度为$O(n^2)$，$n$很大的时候，它肯定会TLE。这就是DFS在这种题目中出现的问题。

今天我们要讲的搜索方式，巧妙地解决了这个问题，使它进行一次搜索就能找到最优解，无需遍历所有的分支。

仔细看~~形象的~~下图~~自 然 奇 观~~：

![adaf2edda3cc7cd9d2011b873901213fb80e91bb](E:\课件\adaf2edda3cc7cd9d2011b873901213fb80e91bb.gif)

Q：这两次打雷有什么特点？

A：我们能看见，第一条闪电裂开成几个分叉，然后这些分叉继续延伸，又产生新的分支，最后逐渐消失在空中。而第二条闪电直接贯穿到底。



如果我们把天空（二维平面）比作一张图，那么闪电的蔓延就相当于图上的搜索。

如你所见，不同的搜索方式会造成闪电出现不同的形状。

第二条闪电从图的上端直接走到下端，走得很**深**，在天空中形成了一条近似的直线。你们已经学过深度优先搜索，这一条闪电相当于**深度优先搜索**的一个分支。当然之后可能会出现其他的闪电，所有这样的直线状闪电构成了对天空这张“图”的深度优先搜索。

而第一条闪电则不同。它从一开始就分裂了，随即向不同的分支蔓延，在天空中所占的范围越来越**广**，它并没有一条闪电贯穿到底。如果这也是一种“搜索”的话，那么它就是我们今天要探讨的主题：**广度优先搜索**（又叫“宽度优先搜索”，英文名为Breadth First Search，缩写BFS）。与之道理相同的还有**广度优先遍历**。广度优先搜索的结果是**广度优先搜索序列**。

##### 2.介绍

对于一棵树（树你们都知道吧），广度优先搜索的方法是：

0.创建一个队列$Q$，其中存储访问过的结点编号。

1.先访问根结点（废话），此时$Q=\{1\}$。

2.访问根结点下的第一层与根结点相连的每一个点，这些点从左到右可以排成一个序列$S^1_1:\{n_1,n_2,n_3...n_{m_1}\}$。其中$m_1$表示第一层的结点数量。将$S^1_1$插入到$Q$中，并从$Q$中删除第一个点$1$。

3.取出序列的第一个点$n_1$。再依次访问第二层与它相连的每一个点$S^2_1:\{n_1,n_2,n_3,...,n_{m_2}\}$。注意这里的$n_1$和上面的$n_1$不是一个结点：它们所属的父结点不同。

4.对于$S_1$里的每个点，重复第3步，分别生成序列$S^2_2,S^2_3,...,S^2_{m_1}$。

5.接着，对于第二层的点所对应的序列，取出每个序列的第一个点，再通过同样的方法进行扩展（即访问第三层）。接着访问第四层，第五层......

6.等到所有点都访问完以后，搜索结束。

也就是说，每次从$Q$中取出第一个元素，然后从这个元素向下进行扩展，将扩展完的元素放在$Q$的最后，最后从$Q$中删除它。

这么说大白话肯定不直观。以下图为例：

![1dd0b8c2d05a69fd3de0a55612d0b739](E:\课件\1dd0b8c2d05a69fd3de0a55612d0b739.jpg)

首先我们访问根节点$1$。$Q=\{1\}$。

然后依次访问直接与它相连的点序列$\{2,5,6,9\}$（第一层）并删除最前面的$1$。$Q=\{2,5,6,9\}$。

然后取出最左边的点$2$，它下面有结点$3,4$（第二层）。依次访问，插入到队列中，并删除$2$。

$Q=\{5,6,9,3,4\}$。

接着是$5$。它下面没有结点，但还是要删除它。$Q=\{6,9,3,4\}$。

然后是$6$。它下面有结点$7$，访问它。注意$8$虽然也在$6$的下面，但是它在第三层，先不访问。

同理，$Q=\{9,3,4,7\}$。

最后是$9$。它下面有结点$10$，访问它。$Q=\{3,4,7,10\}$。

然后到达第三层。$3,4$都没有子节点，直接删除。$Q=\{7,10\}$。

$7$下面还有$8$。访问。$Q=\{10,8\}$。

$10$下面没有结点。删除。$Q=\{8\}$。

第四层，$8$下面没有结点。弹出。$Q$为空。



至此，所有的结点都访问完毕。所有的序列根据被访问时间的先后顺序结合起来，形成一个大序列$\{1,2,5,6,9,3,4,7,10,8\}$。

聪明的你们一定早就发现，这不就是把每一层的结点从左到右读一遍吗！实际上，这就是广度优先搜索序列，也就是说，广度优先搜索的实质是按层搜索。

类似地，我们可以得到这棵树的深度优先搜索序列$\{1,2,3,4,5,6,7,8,9,10\}$。深搜的过程想必上一节课的大佬已经讲给你们了，这里不再赘述。

值得注意的是，这里搜索结束的标志是“所有的点都访问完了”。我们还可以有其他结束条件。比如说“访问到$9$”为结束条件，那么只要访问完第一层就行了。我们可以对取出的结点进行检验，如果这个结点是目标结点，那么直接结束搜索。

##### 3.前置知识：STL-queue

你们已经学会了手写队列。它的原理是：建立两个指针，分别指向队列的头部和尾部。每次向队中加入元素都是从队尾加入，尾指针后移一位。而每次从队中取出元素都是从队头取出，头指针后移一位。队列是一种先进先出的线性结构。

手写队列太麻烦，于是`C++`标准中加入了已经实现的队列，我们可以直接使用。

```cpp
#include<iostream>
#include<queue>//队列头文件
using namespace std;

queue<T> q;//声明一个stl队列，T表示其中的元素类型
q.push(T obj);//(void)在队列尾部加入元素obj
q.front();//(T)返回队列中第一个元素
q.pop();//(void)弹出队列中的第一个元素
q.size();//(int)返回队列中元素个数
q.empty();//(bool)返回队列是否为空

```

`STL`是一个博大精深的`C++`库。里面还有`stack`，`priority_queue`，`vector`等非常有用便利的数据结构，感兴趣的童鞋可以课外了解： https://baike.baidu.com/item/STL/70103?fr=aladdin 

##### 4.BFS的代码实现（你们最想要的）

~~千万不要看书上的代码，它讲得很乱。~~

```cpp
bool vis[MAXN];
void bfs(int start){
    queue<int> q;
    q.push(start);
    vis[start]=true;
    while(!q.empty()){
        int now=q.front();//取出队列首部进行扩展
        q.pop();//弹出，因为我们将来肯定不用在用了
        if(now是目标状态){
            输出结果;
            return;
        }
        for(能过通过now扩展的状态nxt){
            if(!vis[nxt] && OK(nxt)){//这里的OK表示其他的合法性判断
                vis[nxt]=true;//被访问过
                q.push(nxt);//推入队列尾部
            }
        }
    }
    输出“无解”;
    return;
}
```

根据这个思路，我们尝试解决课件一开始DFS无法快速解决的题目。

![捕获2](E:\课件\捕获2.PNG)

我们用结构体`struct point`来存储一个点，同时记录到达这个点所走过的步数：

```cpp
struct point{
    int x,y,dist;
};
```

我们还要开一个布尔数组，表示一个点有没有被访问过：

```cpp
bool vis[MAXN][MAXN];
```

一开始，`vis`里都是`false`。

一般来说，对于这种棋子类BFS问题，我们还要额外建立两个数组，它的意义一会儿就会提到。

```cpp
int dx[8]={1,2,2,1,-1,-2,-2,-1},dy[8]={2,1,-1,-2,-2,-1,1,2};
```

在题目中，$S$点为$(1,1)$（`A`看做`1`，`B,C,D`等同理）。它是搜索的起点，自然也属于整个搜索过程。所以要把它加入队列，由于“马”还没开始走，所以“到达这个点的步数”为$0$。同时它也要标记已访问。

```cpp
point start;
int sx,sy;//表示起始坐标，在这个例子中，sx=sy=1;
start.x=sx;start.y=sy;start.dist=0;
void bfs(){
    queue<point> q;
    q.push(start);
    vis[start.x][start.y]=true;
```

“马”下一步可能**往八个方向**“走日”。它就是“状态”。所以我们要从队列头部取出状态并进行扩展：

```cpp
while(!q.empty()){
    point now=q.front();
	q.pop();
	int x=now.x,y=now.y,d=now.dist;//取出这个状态的信息
```

这里，一开始我们所说的`dx`和`dy`数组就派上用场了。我们可以发现，“马走日操作”实际上就是“马”的**横纵坐标变化**。所以我们可以遍历`dx`和`dy`数组来获取新状态的坐标：

```cpp
	for(int i=0;i<8;i++){
    	int nx=x+dx[i],ny=y+dy[i];
```

同时，“马”因为又走了一步，所以走到新的点时的步数**一定是前一个点的步数$+1$：**

```cpp
		int nd=d+1;
```

接下来就是对新状态的有效性判断了。除了`vis`必须为`false`以外，我们还会发现，**“马”跳到棋盘外面肯定是不行的**，反映到坐标上，就是“马”必须满足：`nx>0 && nx<=MAXX && ny>0 && ny<=MAXY`（只要有一个条件不满足，就证明“马”跳到了棋盘外面）。在这个例子中，`MAXX+MAXY=7`。

因此，`OK`函数应该这样写：

```cpp
bool OK(int x,int y){
    return (x>0 && x<=7 && y>0 && y<=7);
}
```

然后在`bfs`中直接判断：

```cpp
		if((!vis[nx][ny]) && OK(nx,ny)){
            vis[nx][ny]=true;
            point nxt=(point){nx,ny,nd};//这样能达到直接给新结构体赋值的效果
            q.push(nxt);
        }
```

最后就是答案判定了，我们要输出走到终点的步数。值得一提的是，搜索的时候发现了目标状态，我们一般不直接结束搜索，**而是先把它放到队列中**，等到下一次取出这个状态的时候**再进行判定**：

```cpp
		if(x==fx && y==fy){//fx,fy表示终点的横纵坐标
            cout<<now.d<<endl;
            return;
        }
```

最后不要忘记，如果终点放在了一个十分~~隐秘的角落~~，导致**队列空了**都搜不到，那么搜索以失败告终，输出信息：

```cpp
	}//while(!q.empty())
	cout<<"Not Found"<<endl;
    return;
}
```



总体代码：

```cpp
struct point{
    int x,y,dist;
};

bool vis[MAXN][MAXN];
int dx[8]={1,2,2,1,-1,-2,-2,-1},dy[8]={2,1,-1,-2,-2,-1,1,2};
point start;
int fx,fy,sx,sy;

bool OK(int x,int y){
    return (x>0 && x<=7 && y>0 && y<=7);
}

void bfs(){
    queue<point> q;
    
    start.x=sx,start.y=sy,start.dist=0;
    
    q.push(start);
    vis[start.x][start.y]=true;
    
	while(!q.empty()){
    	point now=q.front();
		q.pop();
        
		int x=now.x,y=now.y,d=now.dist;//取出这个状态的信息
        
        if(x==fx && y==fy){
            cout<<now.d<<endl;
            return;
        }
        
   	 	for(int i=0;i<8;i++){
    		int nx=x+dx[i],ny=y+dy[i],nd=d+1;
            
        	if((!vis[nx][ny]) && OK(nx,ny)){
            	vis[nx][ny]=true;
            	point nxt=(point){nx,ny,nd};//这样能达到直接给新结构体赋值的效果
            	q.push(nxt);
    		}
            
        }
        
    }
    
    cout<<"Not Found"<<endl;
    return;
}
       
```

`main`函数大家自己尝试写一下，~~相信都不是问题~~。

还有一个问题：如果还要输出路径怎么办呢？

这时我们还可以建立一个新的`point`类型数组`pre[i][j]`，表示**走到点 (i,j) 这个点的前面那个点是哪个**，也就是这个点的“前驱”，然后每次扩展时进行记录，开始的点没有前驱，赋为`(-1,-1)`。

```cpp
point pre[MAXX][MAXY];
pre[sx][sy].x=-1;
pre[sx][sy].y=-1;

//在扩展时
pre[nx][ny].x=x;
pre[nx][ny].y=y;
```

在发现目标状态时：添加如下函数：

```cpp
        if(x==fx && y==fy){
            cout<<now.d<<endl;
            print(x,y);
            return;
        }
```

其中`print`函数定义如下：

```cpp
void print(int x,int y)
{
    if(x==-1&&y==-1)//没有前驱时返回
        return;
    print(pre[x][y].x,pre[x][y].y);
    printf("(%d, %d)\n",x,y);
}
```

这里用到了递归函数，它的原理是什么，以及为什么递归要放在输出的前面，~~留给读者思考~~。

时间复杂度：$O(n+e)$。~~我也不太会算~~

##### 5.推荐题目

(1)（本节板子） [Knight Moves]( http://ybt.ssoier.cn:8088/problem_show.php?pid=1257 )

(2)（走迷宫问题）[走迷宫]( http://ybt.ssoier.cn:8088/problem_show.php?pid=1252 )

~~(3)（又·走迷宫问题）[走出迷宫]( http://ybt.ssoier.cn:8088/problem_show.php?pid=1254 )~~

~~(4)（双·走迷宫问题）[迷宫问题]( http://ybt.ssoier.cn:8088/problem_show.php?pid=1255 )~~

~~(5)（叒·走迷宫......）[仙岛求药]( http://ybt.ssoier.cn:8088/problem_show.php?pid=1251 )~~

*~~(6)（加 强 版 迷宫）[Dungeon Master]( http://ybt.ssoier.cn:8088/problem_show.php?pid=1248 )~~

(7)（连通块统计）[细胞]( http://ybt.ssoier.cn:8088/problem_show.php?pid=1329 )

*(8)[The Castle]( http://ybt.ssoier.cn:8088/problem_show.php?pid=1250 )

难度依次递增，标有*的题目选做。

在做这些不同类型的题时，一定要思考以下问题：

1.初始状态和目标状态是什么？一个状态满足什么条件才能看作目标状态？

2.`OK`函数怎么写？

3.`point`结构体里需要记录什么？全局需要记录什么？

4.`dx,dy`数组长度是多少？由哪些数字构成？

5.只有仅当队列空的时候才表示搜索失败吗？

6.我们BFS的目的是求出什么？

~~7.为什么这么多迷宫？~~